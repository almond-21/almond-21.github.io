<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PEARL JITTER ARCHIVE</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: white;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script>
        // 🚀 Three.js 기본 설정
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 📌 3차원 와이어프레임 그리드 생성
        const gridSize = 16;  // 그리드 크기
        const gridDivisions = 16;  // 그리드 간격

        // XZ 평면 (바닥 그리드) - 선 색상 흰색으로 설정
        const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0xffffff, 0xffffff);
        gridHelper.material.opacity = 0.2; // 투명도 50%로 설정
        gridHelper.material.transparent = true; // 투명도 적용을 위해 true로 설정
        scene.add(gridHelper);

        // XY 평면 (세로 그리드) - 선 색상 흰색으로 설정
        const gridHelperXY = new THREE.GridHelper(gridSize, gridDivisions, 0xffffff, 0xffffff);
        gridHelperXY.material.opacity = 0.2; // 투명도 50%로 설정
        gridHelperXY.material.transparent = true; // 투명도 적용을 위해 true로 설정
        gridHelperXY.rotation.x = Math.PI / 2;
        scene.add(gridHelperXY);

        // YZ 평면 (옆면 그리드) - 선 색상 흰색으로 설정
        const gridHelperYZ = new THREE.GridHelper(gridSize, gridDivisions, 0xffffff, 0xffffff);
        gridHelperYZ.material.opacity = 0.2; // 투명도 50%로 설정
        gridHelperYZ.material.transparent = true; // 투명도 적용을 위해 true로 설정
        gridHelperYZ.rotation.z = Math.PI / 2;
        scene.add(gridHelperYZ);


        // 📚 텍스트 생성 함수
        function createText(text, position) {
            const loader = new THREE.FontLoader();
            loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                const textGeometry = new THREE.TextGeometry(text, {
                    font: font,
                    size: 0.5,
                    height: 0,
                    curveSegments: 12,
                });

                const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const mesh = new THREE.Mesh(textGeometry, textMaterial);
                mesh.position.set(position.x, position.y, position.z);
                scene.add(mesh);
            });
        }

        // x축 최댓값, 최솟값 텍스트 추가
        createText('CONCRETE', new THREE.Vector3(gridSize / 1.8, 0, 0));
        createText('ABSTRACT', new THREE.Vector3(-gridSize / 1.1, 0, 0));

        // Y축 최댓값, 최솟값 텍스트 추가
        createText('BIG', new THREE.Vector3(0, gridSize / 1.8, 0));
        createText('SMALL', new THREE.Vector3(0, -gridSize / 1.8, 0));

        // Z축 최댓값, 최솟값 텍스트 추가
        createText('SERIOUS', new THREE.Vector3(0, 0, gridSize / 1.8));
        createText('PLAYFUL', new THREE.Vector3(0, 0, -gridSize / 1.8));

        // 📍 흰색 점 추가 (5개) - 특정 좌표로 고정
        const whiteDotMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });  // 흰색 재질
        const dots = []; // 점들을 저장할 배열
        const dotUrls = [  // 점마다 다른 URL 설정
            "fuzzy.html",
            "chunking.html",
            "ski.html",
            "dragon.html",
            "galaga.html",
            "pacguy.html",
            "gather.html",
            "tanghulu.html",
            "blog.html",
            "planmove.html"
        ];

        // 고정된 특정 좌표들
        const fixedPositions = [
            new THREE.Vector3(2, 3, 4),
            new THREE.Vector3(-3, -2, 5),
            new THREE.Vector3(4, -1, -3),
            new THREE.Vector3(-5, 4, 2),
            new THREE.Vector3(1, 5, -4),
            new THREE.Vector3(0, -2, 5),
            new THREE.Vector3(4, 0, -1),
            new THREE.Vector3(-2, 4, 2),
            new THREE.Vector3(1, 1, -4),
            new THREE.Vector3(3, -5, -6)
        ];

        // 점에 텍스트와 이미지를 추가하는 함수
        function createDotTextAndImage(dot, text) {
            const loader = new THREE.FontLoader();
            loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                const textGeometry = new THREE.TextGeometry(text, {
                    font: font,
                    size: 0.3,
                    height: 0,
                    curveSegments: 12,
                });

                const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.set(dot.position.x + 0.5, dot.position.y, dot.position.z);
                scene.add(textMesh);
                dot.textMesh = textMesh;  // 점에 텍스트 메쉬를 추가
            });

            // 이미지 평면 생성
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load(`https://example.com/images/${text}.png`);  // 이미지 경로 설정
            const planeGeometry = new THREE.PlaneGeometry(1, 1);
            const planeMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.position.set(dot.position.x, dot.position.y + 1, dot.position.z); // 점 위에 평면을 배치
            plane.visible = false;  // 처음에는 숨겨둠
            scene.add(plane);
            dot.imagePlane = plane;  // 점에 이미지 평면을 추가
        }

        // 점 5개 생성 (고정된 위치에 배치)
        for (let i = 0; i < 10; i++) {
            const dotGeometry = new THREE.SphereGeometry(0.2, 32, 32);  // 작은 구체
            const whiteDot = new THREE.Mesh(dotGeometry, whiteDotMaterial);
            whiteDot.position.copy(fixedPositions[i]);  // 고정된 위치로 설정
            scene.add(whiteDot);
            whiteDot.url = dotUrls[i]; // 각 점에 URL 추가
            dots.push(whiteDot); // 점 배열에 추가

            // 점 옆에 텍스트 및 이미지 추가
            createDotTextAndImage(whiteDot, "No." + (i + 1));
        }

        // 카메라 위치 조정
        camera.position.set(10, 10, 10);  // 카메라 위치 설정
        camera.lookAt(0, 0, 0);  // 카메라가 (0, 0, 0) 방향을 보도록 설정

        // 🎮 마우스로 회전 제어
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        const rotationSpeed = 0.005;  // 회전 속도 조정
        let currentRotation = { x: 0, y: 0 };  // 현재 회전 상태

        // 마우스 드래그 시작
        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        // 마우스 드래그 종료
        function onMouseUp(event) {
            isDragging = false;
        }

        // 마우스 이동
        function onMouseMove(event) {
            if (!isDragging) return;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            // 회전 속도 조정 (부드럽게)
            currentRotation.y += deltaX * rotationSpeed;
            currentRotation.x += deltaY * rotationSpeed;

            // 회전 범위 제한 (x축과 y축 회전 범위 설정)
            currentRotation.x = Math.max(Math.min(currentRotation.x, Math.PI / 2), -Math.PI / 2);
            currentRotation.y = (currentRotation.y + Math.PI) % (Math.PI * 2) - Math.PI;  // -PI ~ PI 범위로 제한

            // 회전 적용
            scene.rotation.x = currentRotation.x;
            scene.rotation.y = currentRotation.y;

            // 이전 마우스 위치 업데이트
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        window.addEventListener("mousedown", onMouseDown);
        window.addEventListener("mouseup", onMouseUp);
        window.addEventListener("mousemove", onMouseMove);

        // 🔄 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // 📍 마우스 클릭으로 점 클릭 감지
        function onMouseClick(event) {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            // 모든 점들에 대해 raycasting
            for (let i = 0; i < dots.length; i++) {
                const dot = dots[i];
                const intersects = raycaster.intersectObject(dot);

                if (intersects.length > 0) {
                    window.location.href = dot.url;  // 해당 점의 URL로 이동
                    break;
                }
            }
        }

        window.addEventListener("click", onMouseClick, false);


        // 📍 점 크기 변경: 마우스가 점에 가까워지면 크기가 두 배로 커짐, 그리고 이미지 표시
        function onMouseMoveForScaling(event) {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            // 모든 점들에 대해 raycasting
            for (let i = 0; i < dots.length; i++) {
                const dot = dots[i];
                const intersects = raycaster.intersectObject(dot);

                // 이미지 div의 고유 id
                const imageDivId = "dotImage" + i;

                // 일정 범위(예: 100px 이내)에 들어가면 점 크기 두 배로 증가
                if (intersects.length > 0) {
                    dot.scale.set(2, 2, 2);  // 점 크기 두 배로 증가

                    // 텍스트와 이미지 표시
                    if (dot.textMesh) {
                        dot.textMesh.visible = true;  // 텍스트 표시
                    }

                    // 이미지 표시 (새로운 div 생성)
                    let imageDiv = document.getElementById(imageDivId);
                    if (!imageDiv) {
                        imageDiv = document.createElement('div');
                        imageDiv.id = imageDivId;
                        imageDiv.style.position = 'absolute';
                        imageDiv.style.width = '100px';
                        imageDiv.style.height = '100px';
                        imageDiv.style.pointerEvents = 'none';  // 이미지 클릭 방지
                        document.body.appendChild(imageDiv);
                    }
                    imageDiv.style.display = 'block';  // 이미지 표시
                    imageDiv.style.left = `${event.clientX - 110}px`;
                    imageDiv.style.top = `${event.clientY - 110}px`;
                    imageDiv.style.backgroundImage = `url('thumbnail/${i + 1}.png')`;  // 이미지 경로는 1.png, 2.png ...
                    imageDiv.style.backgroundSize = 'cover';
                } else {
                    dot.scale.set(1, 1, 1);  // 원래 크기로 돌아옴

                    // 텍스트 숨기기
                    if (dot.textMesh) {
                        dot.textMesh.visible = false;
                    }

                    // 이미지 숨기기
                    const imageDiv = document.getElementById(imageDivId);
                    if (imageDiv) {
                        imageDiv.style.display = 'none';
                    }
                }
            }
        }

        window.addEventListener("mousemove", onMouseMoveForScaling, false);


    </script>
</body>

</html>